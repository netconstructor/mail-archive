#!/usr/bin/perl -Tw
#
# Script to accept email messages on standard input and file all of their
# parts in a filing system, deduplicating each of the MIME parts by hard
# linking to another identical file, if one exists.
#
# There should never be any need to run this directly except for debugging.
# See .mailfilter for normal usage.
#
# Copyright (c) 2011 Lowenstein & Stumpo <http://www.lowstump.com.au/>
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author:	Paul Gear <github@libertysys.com.au>
#

use strict;

use Email::Address;
use Email::MIME;
use Getopt::Long;
use Scalar::Util qw/tainted/;

use lib ".";

use MailArchive::Archive;
use MailArchive::Email;
use MailArchive::Util;

MailArchive::Util->init($0);

my $split = 1;
my $debug = getdebug();
my $magic_header;

# functions which may need customising on local sites
require "site.pl";

my $result = GetOptions(
	#"length=i"	=> \$length,    # numeric
	#"file=s"	=> \$data,      # string
	"debug"		=> \$debug,	# boolean
	"split"		=> \$split,	# split the email into MIME parts -
					# if false, just save the whole file
);

setdebug($debug);

my $basedir = shift @ARGV;
my $projnum = shift @ARGV;
my $projdir;

# check and untaint base directory
$basedir = validate_directory($basedir);

# read our input email
my $email = read_stdin();

# open parsed version of the email
my $msg = Email::MIME->new($email);

# get the message headers
my $subject = $msg->header("Subject");
my $from = $msg->header("From");
my $to = $msg->header("To");

# check if we've already processed this message
my $magic = $msg->header($magic_header);
if (defined $magic) {
	debug "Dropping message, already processed: $magic";
	exit 0;
}

# check for any messages to drop
my $check_drop = get_drop_flags($subject, $from, $to);
if (defined $check_drop) {
	debug "Dropping email: $check_drop";
	exit 0;
}

# validate project number
$projnum = check_project_num(defined $projnum ? $projnum : $subject);
unless (defined $projnum) {
	# @@@ TODO - insert magic header & send mail to administrator
}

error "Project number $projnum tainted" if tainted($projnum);

# remove noise from subject
$subject = clean_subject($subject, $projnum);

# search for project directory
$projdir = get_project_dir($basedir, $projnum);
error "Project directory for $projnum not found" unless defined $projdir;
error "Project directory $projdir tainted" if tainted($projdir);
debug "Project directory is $projdir";

# work out whether the message is incoming or outgoing
my @fromaddr = Email::Address->parse($from);
dump_email_address "fromaddr", $fromaddr[0];
my $outgoing = is_outgoing(@fromaddr);

# get primary recpient
my @toaddr = Email::Address->parse($to);
dump_email_addresses "toaddr", @toaddr;

# use the other party as an identifier
my $otherparty;
if ($outgoing) {
	$otherparty = join(" ", map {$_->name, $_->address} @toaddr);
}
else {
	$otherparty = $fromaddr[0]->name . " " . $fromaddr[0]->address;
}
debug "otherparty = $otherparty";

# get the incoming/outgoing correspondence directory
my $emaildir = get_project_email_dir($projdir, $outgoing);
debug "emaildir = $emaildir";

# use the date, subject, and otherparty to create a unique directory name within the correspondence directory
my $yyyymmdd = yyyymmdd();
my $uniquebase = "$emaildir/$yyyymmdd $otherparty $subject";
debug "uniquebase = ($uniquebase)";

if ($split) {
	# split into parts and process the message
	process_message($uniquebase, $msg);
}
else {
	# save the whole file
	save_file(get_unique_filename($uniquebase), "email archive file", $email);
}

